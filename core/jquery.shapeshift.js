// Generated by CoffeeScript 1.4.0
(function() {

  (function($, window, document, undefined_) {
    var Plugin, defaults, pluginName;
    pluginName = "shapeshift";
    defaults = {
      enableResize: true,
      resizeRate: 300,
      cssAnimations: false,
      state: 'default',
      states: {
        "default": {
          animated: false,
          animateSpeed: 100,
          staggerInit: true,
          staggerSpeed: 1,
          grid: {
            align: 'center',
            columns: null,
            colWidth: null,
            gutter: [10, 10],
            padding: [50, 50]
          },
          "class": 'default',
          initClass: 'init'
        },
        secondary: {
          animated: true,
          animateSpeed: 100,
          grid: {
            align: 'center',
            columns: null,
            colWidth: null,
            gutter: [10, 10],
            padding: [400, 20]
          },
          "class": 'secondary',
          initClass: 'init'
        }
      }
    };
    Plugin = function(element, options) {
      this.options = $.extend({}, defaults, options);
      this.grid = {};
      this.$container = $(element);
      this.children = [];
      this.stagger_queue = [];
      this.stagger_interval = null;
      this.state = this.options.states[this.options.state];
      return this.init();
    };
    Plugin.prototype = {
      init: function() {
        this._enableFeatures();
        this._parseChildren();
        this._initializeGrid();
        return this._arrange();
      },
      insert: function($child, i) {
        if (i === void 0) {
          i = 999999;
        }
        this.$container.append($child);
        this._parseChild($child, i);
        this._calculateGrid();
        return this._arrange();
      },
      insertMany: function(children) {
        var $child, child, index, _i, _len;
        for (_i = 0, _len = children.length; _i < _len; _i++) {
          child = children[_i];
          $child = child[0];
          index = child[1] || 999999;
          this.$container.append($child);
          this._parseChild($child, index);
        }
        this._calculateGrid();
        return this._arrange();
      },
      setState: function(state_name) {
        var child, state, _i, _len, _ref;
        state = this.options.states[state_name];
        if (state) {
          _ref = this.children;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            child = _ref[_i];
            child.el.removeClass(this.state["class"]).addClass(state["class"]);
          }
          this.state = state;
          this._initializeGrid();
          return this._arrange();
        } else {
          return console.error("Shapeshift does not recognize the state '" + state_name + "', are you sure it's defined?");
        }
      },
      shuffle: function() {
        var a, i, j, t;
        a = this.children;
        i = a.length;
        while (--i > 0) {
          j = ~~(Math.random() * (i + 1));
          t = a[j];
          a[j] = a[i];
          a[i] = t;
        }
        this.children = a;
        return this._arrange();
      },
      _enableFeatures: function() {
        if (this.options.enableResize) {
          return this.enableResize();
        }
      },
      _parseChildren: function() {
        var $child, $children, child_count, i, _i;
        $children = this.$container.children();
        child_count = $children.length;
        for (i = _i = 0; 0 <= child_count ? _i < child_count : _i > child_count; i = 0 <= child_count ? ++_i : --_i) {
          $child = $($children[i]);
          this._parseChild($child, i);
        }
        return this;
      },
      _parseChild: function($child, i) {
        return this.children.splice(i, 0, {
          el: $child,
          colspan: parseInt($child.attr("data-ss-colspan")) || 1,
          height: $child.outerHeight(),
          position: null,
          initialized: false
        });
      },
      _initializeGrid: function() {
        var fc_colspan, fc_width, first_child, grid_state, gutter_x, single_width;
        grid_state = this.state.grid;
        gutter_x = grid_state.gutter[0];
        if (grid_state.colWidth) {
          this.grid.col_width = grid_state.colWidth + gutter_x;
        } else {
          first_child = this.children[0];
          fc_width = first_child.el.outerWidth();
          fc_colspan = first_child.colspan;
          single_width = (fc_width - ((fc_colspan - 1) * gutter_x)) / fc_colspan;
          this.grid.col_width = single_width + gutter_x;
        }
        this.grid.paddingX = grid_state.padding[0];
        this.grid.paddingY = grid_state.padding[1];
        return this._calculateGrid();
      },
      _calculateGrid: function() {
        var child_offset, col_width, columns, container_width, grid_state, grid_width, padding_x;
        grid_state = this.state.grid;
        col_width = this.grid.col_width;
        padding_x = grid_state.padding[0];
        container_width = this.$container.innerWidth() - (padding_x * 2);
        columns = grid_state.columns || Math.floor(container_width / col_width);
        if (columns > this.children.length) {
          columns = this.children.length;
        }
        this.grid.columns = columns;
        child_offset = this.grid.paddingX;
        grid_width = (columns * col_width) - grid_state.gutter[0];
        switch (grid_state.align) {
          case "center":
            child_offset += (container_width - grid_width) / 2;
            break;
          case "right":
            child_offset += container_width - grid_width;
        }
        return this.grid.child_offset = child_offset;
      },
      _arrange: function() {
        var $child, child, i, init_class, initialize, normal_class, position, position_string, positions, stagger_init, stagger_queue, stagger_speed, _i, _len, _ref;
        if (this.stagger_queue.length) {
          this._clearStaggerQueue();
        }
        positions = this._getPositions();
        init_class = this.state.initClass;
        normal_class = this.state["class"];
        stagger_speed = this.state.staggerSpeed;
        stagger_init = this.state.staggerInit;
        stagger_queue = [];
        this.$container.css({
          height: this.grid.height
        });
        _ref = this.children;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          child = _ref[i];
          $child = child.el;
          initialize = !child.initialized;
          position = positions[i];
          if (initialize) {
            $child.addClass(init_class);
            child.initialized = true;
          }
          position_string = JSON.stringify(position);
          if (position_string !== child.position) {
            if (initialize) {
              stagger_queue.push([$child, position]);
            } else {
              this._move($child, position);
            }
            child.position = position_string;
          }
        }
        if (stagger_queue.length) {
          this._staggerMove(stagger_queue);
        }
        return this;
      },
      _clearStaggerQueue: function() {
        var $child, child, position, stagger_queue, _i, _len;
        clearInterval(this.stagger_interval);
        this.stagger_interval = null;
        stagger_queue = this.stagger_queue;
        for (_i = 0, _len = stagger_queue.length; _i < _len; _i++) {
          child = stagger_queue[_i];
          if (child) {
            $child = child[0];
            position = child[1];
            this._move($child, position);
          }
        }
        return this.stagger_queue = [];
      },
      _staggerMove: function(stagger_queue) {
        var $child, child, i, position, _i, _len, _results,
          _this = this;
        if (this.state.staggerInit) {
          i = 0;
          this.stagger_queue = stagger_queue;
          return this.stagger_interval = setInterval(function() {
            var $child, child, position;
            child = stagger_queue[i];
            if (child) {
              $child = child[0];
              position = child[1];
              _this._move($child, position);
              _this.stagger_queue[i] = null;
              return i++;
            } else {
              clearInterval(_this.stagger_interval);
              return _this.stagger_interval = null;
            }
          }, this.state.staggerSpeed);
        } else {
          _results = [];
          for (_i = 0, _len = stagger_queue.length; _i < _len; _i++) {
            child = stagger_queue[_i];
            $child = child[0];
            position = child[1];
            _results.push(this._staggerTimeout($child, position));
          }
          return _results;
        }
      },
      _staggerTimeout: function($child, position) {
        var _this = this;
        return setTimeout(function() {
          return _this._move($child, position);
        }, 0);
      },
      _move: function($child, position) {
        var _this = this;
        $child.css(position);
        return setTimeout(function() {
          return $child.addClass(_this.state["class"]).removeClass(_this.state.initClass);
        }, 0);
      },
      _getPositions: function() {
        var child, col, col_heights, col_width, gutter_y, i, offset_left, padding_y, positions, _i, _j, _len, _ref, _ref1;
        col_width = this.grid.col_width;
        gutter_y = this.state.grid.gutter[1];
        padding_y = this.grid.paddingY;
        col_heights = [];
        for (i = _i = 0, _ref = this.grid.columns; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          col_heights.push(padding_y);
        }
        positions = [];
        offset_left = this.grid.child_offset;
        _ref1 = this.children;
        for (i = _j = 0, _len = _ref1.length; _j < _len; i = ++_j) {
          child = _ref1[i];
          col = this.lowestCol(col_heights);
          positions.push({
            left: (col * col_width) + offset_left,
            top: col_heights[col]
          });
          col_heights[col] += child.height + gutter_y;
        }
        this.grid.height = this.highestCol(col_heights) - gutter_y + padding_y;
        return positions;
      },
      lowestCol: function(array) {
        return $.inArray(Math.min.apply(window, array), array);
      },
      highestCol: function(array) {
        return array[$.inArray(Math.max.apply(window, array), array)];
      },
      enableResize: function() {
        var resizing, speed,
          _this = this;
        speed = this.options.resizeRate;
        resizing = false;
        return $(window).on("resize", function() {
          if (!resizing) {
            resizing = true;
            setTimeout(function() {
              _this._calculateGrid();
              return _this._arrange();
            }, speed * .6);
            return setTimeout(function() {
              _this._calculateGrid();
              _this._arrange();
              return resizing = false;
            }, speed * 1.1);
          }
        });
      }
    };
    return $.fn[pluginName] = function(options) {
      var args, returns, scoped_name;
      args = arguments;
      scoped_name = "plugin_" + pluginName;
      if (options === undefined || typeof options === "object") {
        return this.each(function() {
          if (!$.data(this, scoped_name)) {
            return $.data(this, scoped_name, new Plugin(this, options));
          }
        });
      } else if (typeof options === "string" && options[0] !== "_" && options !== "init") {
        returns = void 0;
        this.each(function() {
          var instance;
          instance = $.data(this, scoped_name);
          if (instance instanceof Plugin && typeof instance[options] === "function") {
            returns = instance[options].apply(instance, Array.prototype.slice.call(args, 1));
          }
          if (options === "destroy") {
            return $.data(this, scoped_name, null);
          }
        });
        if (returns !== undefined) {
          return returns;
        } else {
          return this;
        }
      }
    };
  })(jQuery, window, document);

}).call(this);
