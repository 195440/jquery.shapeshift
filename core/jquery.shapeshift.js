// Generated by CoffeeScript 1.4.0
(function() {

  (function($, window, document, undefined_) {
    var Plugin, defaults, pluginName;
    pluginName = "shapeshift";
    defaults = {
      enableResize: true,
      resizeRate: 300,
      cssAnimations: true,
      state: 'default',
      states: {
        "default": {
          animated: false,
          animateSpeed: 100,
          staggerInit: true,
          staggerSpeed: 50,
          grid: {
            align: 'center',
            columns: null,
            colWidth: 200,
            gutter: ["auto", 10],
            padding: [0, 0]
          },
          "class": 'default',
          initClass: 'init'
        },
        secondary: {
          animated: true,
          animateSpeed: 100,
          grid: {
            align: 'center',
            columns: null,
            colWidth: null,
            gutter: [10, 10],
            padding: [50, 50]
          },
          "class": 'secondary',
          initClass: 'init'
        }
      }
    };
    Plugin = function(element, options) {
      this.options = $.extend({}, defaults, options);
      this.grid = {};
      this.grid.percent_cols = false;
      this.$container = $(element);
      this.children = [];
      this.stagger_queue = [];
      this.stagger_interval = null;
      this.state = this.options.states[this.options.state];
      return this.init();
    };
    Plugin.prototype = {
      init: function() {
        this._enableFeatures();
        this._parseChildren();
        this._initializeGrid();
        return this._arrange();
      },
      insert: function($child, i) {
        if (i === void 0) {
          i = 999999;
        }
        this._parseChild($child, i);
        this._calculateGrid();
        return this._arrange();
      },
      insertMany: function(children) {
        var $child, child, index, _i, _len;
        for (_i = 0, _len = children.length; _i < _len; _i++) {
          child = children[_i];
          $child = child[0];
          index = child[1] || 999999;
          this.$container.append($child);
          this._parseChild($child, index);
        }
        this._calculateGrid();
        return this._arrange();
      },
      setState: function(state_name) {
        var child, cssAnimations, new_state_class, old_state_class, state, _i, _len, _ref;
        state = this.options.states[state_name];
        if (state) {
          cssAnimations = this.options.cssAnimations;
          old_state_class = this.state["class"];
          new_state_class = state["class"];
          _ref = this.children;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            child = _ref[_i];
            if (cssAnimations) {
              child.el.removeClass(old_state_class).addClass(new_state_class);
            } else {
              child.el.switchClass(old_state_class, new_state_class, this.options.animateSpeed);
            }
          }
          this.state = state;
          this._initializeGrid();
          return this._arrange();
        } else {
          return console.error("Shapeshift does not recognize the state '" + state_name + "', are you sure it's defined?");
        }
      },
      shuffle: function() {
        var a, i, j, t;
        a = this.children;
        i = a.length;
        while (--i > 0) {
          j = ~~(Math.random() * (i + 1));
          t = a[j];
          a[j] = a[i];
          a[i] = t;
        }
        this.children = a;
        return this._arrange();
      },
      _enableFeatures: function() {
        if (this.options.enableResize) {
          return this.enableResize();
        }
      },
      _parseChildren: function() {
        var $child, $children, child_count, i, _i;
        $children = this.$container.children();
        child_count = $children.length;
        for (i = _i = 0; 0 <= child_count ? _i < child_count : _i > child_count; i = 0 <= child_count ? ++_i : --_i) {
          $child = $($children[i]);
          this._parseChild($child, i);
        }
        return this;
      },
      _parseChild: function($child, i) {
        return this.children.splice(i, 0, {
          el: $child,
          colspan: parseInt($child.attr("data-ss-colspan")) || 1,
          height: $child.outerHeight(),
          position: null,
          initialized: false
        });
      },
      _initializeGrid: function() {
        var col_width, first_child_width;
        col_width = this.state.grid.colWidth;
        this.grid.percent_cols = false;
        if (col_width === null) {
          first_child_width = this.children[0].el.outerWidth();
          col_width = first_child_width;
        } else if (typeof col_width === 'string') {
          this.grid.percent_cols = col_width;
        }
        this.grid.col_width = col_width;
        return this._calculateGrid();
      },
      _calculateGrid: function() {
        var col_width, columns, container_width, gutter_x, remainder;
        container_width = this.$container.innerWidth() - (this.state.grid.padding[0] * 2);
        col_width = this.state.grid.colWidth;
        gutter_x = this.state.grid.gutter[0];
        if (this.grid.percent_cols) {
          col_width = Math.floor(container_width * (parseInt(col_width) * .01));
        } else {
          col_width = this.grid.col_width;
        }
        if (gutter_x === 'auto') {
          columns = Math.floor(container_width / col_width);
          if (columns > 1) {
            remainder = container_width - (columns * col_width);
            gutter_x = Math.floor(remainder / (columns - 1));
          } else {
            gutter_x = 0;
          }
        } else if (typeof gutter_x === 'string') {
          gutter_x = Math.floor(container_width * (parseInt(gutter_x) * .01));
          columns = Math.floor((container_width + gutter_x) / (col_width + gutter_x));
        }
        this.grid.columns = columns;
        this.grid.col_width = col_width;
        this.grid.gutter_x = gutter_x;
        this.grid.padding_x = 0;
        this.grid.padding_y = 0;
        return this.grid.child_offset = this.state.grid.padding[0];
      },
      _arrange: function() {
        var $child, child, i, init_class, initialize, normal_class, position, position_string, positions, stagger_init, stagger_queue, stagger_speed, _i, _len, _ref;
        if (this.stagger_queue.length) {
          this._clearStaggerQueue();
        }
        positions = this._getPositions();
        init_class = this.state.initClass;
        normal_class = this.state["class"];
        stagger_speed = this.state.staggerSpeed;
        stagger_init = this.state.staggerInit;
        stagger_queue = [];
        this.$container.css({
          height: this.grid.height
        });
        _ref = this.children;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          child = _ref[i];
          $child = child.el;
          initialize = !child.initialized;
          position = positions[i];
          if (initialize) {
            $child.addClass(init_class);
            child.initialized = true;
          }
          position_string = JSON.stringify(position);
          if (position_string !== child.position) {
            if (initialize) {
              stagger_queue.push([$child, position]);
            } else {
              this._move($child, position);
            }
            child.position = position_string;
          }
        }
        if (stagger_queue.length) {
          this._staggerMove(stagger_queue);
        }
        return this;
      },
      _clearStaggerQueue: function() {
        var $child, child, position, stagger_queue, _i, _len;
        clearInterval(this.stagger_interval);
        this.stagger_interval = null;
        stagger_queue = this.stagger_queue;
        for (_i = 0, _len = stagger_queue.length; _i < _len; _i++) {
          child = stagger_queue[_i];
          if (child) {
            $child = child[0];
            position = child[1];
            this._move($child, position, true);
          }
        }
        return this.stagger_queue = [];
      },
      _staggerMove: function(stagger_queue) {
        var $child, child, i, position, _i, _len, _results,
          _this = this;
        if (this.state.staggerInit) {
          i = 0;
          this.stagger_queue = stagger_queue;
          return this.stagger_interval = setInterval(function() {
            var $child, child, position;
            child = stagger_queue[i];
            if (child) {
              $child = child[0];
              position = child[1];
              _this._move($child, position, true);
              _this.stagger_queue[i] = null;
              return i++;
            } else {
              clearInterval(_this.stagger_interval);
              return _this.stagger_interval = null;
            }
          }, this.state.staggerSpeed);
        } else {
          _results = [];
          for (_i = 0, _len = stagger_queue.length; _i < _len; _i++) {
            child = stagger_queue[_i];
            $child = child[0];
            position = child[1];
            _results.push(this._staggerTimeout($child, position));
          }
          return _results;
        }
      },
      _staggerTimeout: function($child, position) {
        var _this = this;
        return setTimeout(function() {
          return _this._move($child, position, true);
        }, 0);
      },
      _move: function($child, position, initialize_state) {
        var animate_speed, css_animations,
          _this = this;
        if (initialize_state == null) {
          initialize_state = false;
        }
        css_animations = this.options.cssAnimations;
        if (css_animations) {
          $child.css(position);
        } else {
          animate_speed = this.options.animateSpeed;
          $child.stop(true, false).animate(position, animate_speed);
        }
        if (initialize_state) {
          return setTimeout(function() {
            if (css_animations) {
              return $child.addClass(_this.state["class"]).removeClass(_this.state.initClass);
            } else {
              return $child.switchClass(_this.state.initClass, _this.state["class"], animate_speed);
            }
          }, 0);
        }
      },
      _getPositions: function() {
        var child, col, col_heights, col_width, gutter_y, i, offset_left, padding_y, positions, _i, _j, _len, _ref, _ref1;
        col_width = this.grid.col_width + this.grid.gutter_x;
        gutter_y = this.state.grid.gutter[1];
        padding_y = this.grid.padding_y;
        col_heights = [];
        for (i = _i = 0, _ref = this.grid.columns; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          col_heights.push(padding_y);
        }
        positions = [];
        offset_left = this.grid.child_offset;
        _ref1 = this.children;
        for (i = _j = 0, _len = _ref1.length; _j < _len; i = ++_j) {
          child = _ref1[i];
          col = this.lowestCol(col_heights);
          positions.push({
            left: (col * col_width) + offset_left,
            top: col_heights[col]
          });
          col_heights[col] += child.height + gutter_y;
        }
        this.grid.height = this.highestCol(col_heights) - gutter_y + padding_y;
        return positions;
      },
      lowestCol: function(array) {
        return $.inArray(Math.min.apply(window, array), array);
      },
      highestCol: function(array) {
        return array[$.inArray(Math.max.apply(window, array), array)];
      },
      enableResize: function() {
        var resizing, speed,
          _this = this;
        speed = this.options.resizeRate;
        resizing = false;
        return $(window).on("resize", function() {
          if (!resizing) {
            resizing = true;
            setTimeout(function() {
              _this._calculateGrid();
              return _this._arrange();
            }, speed * .6);
            return setTimeout(function() {
              _this._calculateGrid();
              _this._arrange();
              return resizing = false;
            }, speed * 1.1);
          }
        });
      }
    };
    return $.fn[pluginName] = function(options) {
      var args, returns, scoped_name;
      args = arguments;
      scoped_name = "plugin_" + pluginName;
      if (options === undefined || typeof options === "object") {
        return this.each(function() {
          if (!$.data(this, scoped_name)) {
            return $.data(this, scoped_name, new Plugin(this, options));
          }
        });
      } else if (typeof options === "string" && options[0] !== "_" && options !== "init") {
        returns = void 0;
        this.each(function() {
          var instance;
          instance = $.data(this, scoped_name);
          if (instance instanceof Plugin && typeof instance[options] === "function") {
            returns = instance[options].apply(instance, Array.prototype.slice.call(args, 1));
          }
          if (options === "destroy") {
            return $.data(this, scoped_name, null);
          }
        });
        if (returns !== undefined) {
          return returns;
        } else {
          return this;
        }
      }
    };
  })(jQuery, window, document);

}).call(this);
